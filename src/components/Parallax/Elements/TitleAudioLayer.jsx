// src/components/Parallax/Elements/TitleAudioLayer.jsx
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { createPortal } from 'react-dom';
import ErrorBoundary from '../../ErrorBoundary';

const TitleAudioLayer = ({ currentTitleIndex, isScrollLocked, scrollToTitleIndex }) => {
    // Refs f√ºr alle Audio-Elemente
    const audioRefs = useRef([]);
    const currentlyPlayingRef = useRef(null);
    const audioTimeoutRef = useRef(null); // ‚úÖ NEU: Timeout-Tracking
    const isPlayingAudioRef = useRef(false); // ‚úÖ NEU: Audio-Status-Lock

    // States
    const [loadingStates, setLoadingStates] = useState({});
    const [errorStates, setErrorStates] = useState({});
    const [isAudioEnabled, setIsAudioEnabled] = useState(true);

    // ‚úÖ ROBUSTE REF-BASIERTE L√ñSUNG
    const isAutoPlayingRef = useRef(false);
    const isAutoPlayStartingRef = useRef(false);
    const [autoPlayUIState, setAutoPlayUIState] = useState(false); // Nur f√ºr UI-Updates

    const lastManualPhaseRef = useRef(0);

    // ‚úÖ NEU: Portal f√ºr Buttons au√üerhalb der Component-Hierarchie
    const [buttonPortal, setButtonPortal] = useState(null);

    // Audio-Konfiguration mit allen 6 Titeln
    const titleAudios = [
        {
            id: 'von-uns-hei√üt-fuer-uns',
            basePath: '/audio/von-uns-hei√üt-fuer-uns',
            title: 'Von Uns Ist F√ºr Uns',
            phase: 1
        },
        {
            id: 'der-weg',
            basePath: '/audio/der-weg',
            title: 'Der Weg',
            phase: 2
        },
        {
            id: 'ist-das-ziel',
            basePath: '/audio/ist-das-ziel',
            title: 'Ist Das Ziel',
            phase: 3
        },
        {
            id: 'die-community',
            basePath: '/audio/die-community',
            title: 'Die Community',
            phase: 4
        },
        {
            id: 'hei√üt',
            basePath: '/audio/hei√üt',
            title: 'Hei√üt',
            phase: 5
        },
        {
            id: 'anitune-theme',
            basePath: '/audio/anitune-theme',
            title: 'AniTune',
            phase: 6
        }
    ];

    // ‚úÖ Portal f√ºr Buttons erstellen
    useEffect(() => {
        const buttonContainer = document.createElement('div');
        buttonContainer.id = 'audio-controls-portal';
        buttonContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999999;
        `;
        document.body.appendChild(buttonContainer);
        setButtonPortal(buttonContainer);

        return () => {
            if (document.body.contains(buttonContainer)) {
                document.body.removeChild(buttonContainer);
            }
        };
    }, []);

    // Audio-Loading-Handler
    const handleAudioLoad = useCallback((index) => {
        setLoadingStates(prev => ({
            ...prev,
            [index]: false
        }));

        console.log(`üéµ Audio ${index + 1} (${titleAudios[index].title}) geladen`);
    }, [titleAudios]);

    // Audio-Error-Handler
    const handleAudioError = useCallback((index, error) => {
        setErrorStates(prev => ({
            ...prev,
            [index]: true
        }));

        console.warn(`‚ùå Audio ${index + 1} (${titleAudios[index].title}) konnte nicht geladen werden:`, error);
    }, [titleAudios]);

    // ‚úÖ ROBUSTE REF-BASIERTE: Audio-Ende Handler f√ºr Auto-Play
    const handleAudioEnded = useCallback((audioIndex) => {
        console.log(`üîö Audio ${audioIndex + 1} beendet - Auto-Play Status: ${isAutoPlayingRef.current}`);

        // Doppelt pr√ºfen ob Auto-Play noch aktiv ist
        if (!isAutoPlayingRef.current) {
            console.log(`‚èπÔ∏è Auto-Play ist gestoppt - keine weitere Aktion`);
            return;
        }

        const currentPhase = audioIndex + 1; // audioIndex 0-5 ‚Üí Phase 1-6
        const nextPhase = currentPhase + 1;   // N√§chste Phase

        console.log(`‚è≠Ô∏è Auto-Play: Von Phase ${currentPhase} zu Phase ${nextPhase}`);

        if (nextPhase <= 6) {
            // L√§ngere Verz√∂gerung f√ºr zuverl√§ssigere √úberg√§nge
            setTimeout(() => {
                // Nochmal pr√ºfen ob Auto-Play noch aktiv ist
                if (isAutoPlayingRef.current && scrollToTitleIndex) {
                    console.log(`üéØ Navigiere zu Phase ${nextPhase} (Auto-Play aktiv)`);
                    scrollToTitleIndex(nextPhase);
                } else {
                    console.log(`‚ùå Auto-Play gestoppt oder scrollToTitleIndex nicht verf√ºgbar`);
                }
            }, 800); // L√§ngere Pause f√ºr bessere UX
        } else {
            console.log(`üèÅ Auto-Play Sequenz beendet - alle Phasen abgespielt`);
            isAutoPlayingRef.current = false;
            setAutoPlayUIState(false);
        }
    }, [scrollToTitleIndex]); // ‚úÖ KEINE DEPENDENCIES AUF STATES!

    // ‚úÖ ROBUSTE REF-BASIERTE: Audio abspielen mit Anti-Stotter-Schutz
    const playAudio = useCallback((audioIndex) => {
        // ‚úÖ SCHUTZ: Verhindere mehrfache gleichzeitige Aufrufe
        if (isPlayingAudioRef.current) {
            console.log(`‚è∏Ô∏è Audio ${audioIndex + 1} - bereits am Abspielen, √ºberspringe`);
            return;
        }

        if (!isAudioEnabled || errorStates[audioIndex]) {
            console.log(`‚ùå Audio ${audioIndex} kann nicht abgespielt werden - disabled: ${!isAudioEnabled}, error: ${errorStates[audioIndex]}`);
            return;
        }

        const audio = audioRefs.current[audioIndex];
        if (!audio) {
            console.log(`‚ùå Audio Element ${audioIndex} nicht gefunden`);
            return;
        }

        // ‚úÖ SCHUTZ: Pr√ºfe ob Audio geladen ist
        if (audio.readyState < 2) { // HAVE_CURRENT_DATA
            console.log(`‚è≥ Audio ${audioIndex + 1} noch nicht geladen - warte...`);
            setTimeout(() => playAudio(audioIndex), 200);
            return;
        }

        console.log(`üéµ Starte Audio ${audioIndex + 1}: ${titleAudios[audioIndex].title}`);
        isPlayingAudioRef.current = true; // ‚úÖ LOCK setzen

        // ‚úÖ CLEANUP: Stoppe aktuell spielendes Audio vollst√§ndig
        if (currentlyPlayingRef.current && currentlyPlayingRef.current !== audio) {
            const oldAudio = currentlyPlayingRef.current;
            oldAudio.pause();
            oldAudio.currentTime = 0;
            oldAudio.onended = null;

            // Clear alter Timer
            if (oldAudio.fallbackTimer) {
                clearTimeout(oldAudio.fallbackTimer);
                oldAudio.fallbackTimer = null;
            }
        }

        // ‚úÖ Clear bestehende Timeout falls vorhanden
        if (audioTimeoutRef.current) {
            clearTimeout(audioTimeoutRef.current);
            audioTimeoutRef.current = null;
        }

        // ‚úÖ Audio-Ende Event hinzuf√ºgen (nur einmal!)
        audio.onended = () => {
            console.log(`üîö Audio ${audioIndex + 1} beendet (onended Event)`);
            isPlayingAudioRef.current = false; // ‚úÖ LOCK entfernen

            // Clear Timer da Audio nat√ºrlich beendet
            if (audio.fallbackTimer) {
                clearTimeout(audio.fallbackTimer);
                audio.fallbackTimer = null;
            }

            handleAudioEnded(audioIndex);
        };

        // ‚úÖ FALLBACK: Timer als Backup (robuster)
        const audioDuration = audio.duration || 5; // K√ºrzerer Fallback
        audio.fallbackTimer = setTimeout(() => {
            if (currentlyPlayingRef.current === audio && isAutoPlayingRef.current) {
                console.log(`‚è∞ Fallback-Timer: Audio ${audioIndex + 1} sollte beendet sein`);
                isPlayingAudioRef.current = false; // ‚úÖ LOCK entfernen
                handleAudioEnded(audioIndex);
            }
        }, (audioDuration + 0.5) * 1000); // K√ºrzerer Puffer

        // ‚úÖ Spiele Audio ab
        audio.currentTime = 0;
        const playPromise = audio.play();

        if (playPromise !== undefined) {
            playPromise
                .then(() => {
                    currentlyPlayingRef.current = audio;
                    console.log(`‚úÖ Audio ${audioIndex + 1} wird abgespielt - Dauer: ${audio.duration}s`);
                })
                .catch(error => {
                    console.warn(`‚ùå Audio-Wiedergabe fehlgeschlagen:`, error);
                    isPlayingAudioRef.current = false; // ‚úÖ LOCK entfernen bei Fehler

                    // Clear Timer bei Fehler
                    if (audio.fallbackTimer) {
                        clearTimeout(audio.fallbackTimer);
                        audio.fallbackTimer = null;
                    }

                    // Bei Auto-Play: Versuche n√§chste Phase nach Verz√∂gerung
                    if (isAutoPlayingRef.current) {
                        console.log(`üîÑ Audio-Fehler - versuche n√§chste Phase in 1s`);
                        audioTimeoutRef.current = setTimeout(() => {
                            handleAudioEnded(audioIndex);
                        }, 1000);
                    }
                });
        }
    }, [isAudioEnabled, errorStates, titleAudios, handleAudioEnded]); // ‚úÖ KEINE AUTO-PLAY DEPENDENCY!

    // ‚úÖ ROBUSTE: Audio stoppen mit vollst√§ndigem Cleanup
    const stopAudio = useCallback(() => {
        console.log(`‚èπÔ∏è Audio gestoppt - vollst√§ndiges Cleanup`);

        // ‚úÖ CLEANUP: Alle Timer clearen
        if (audioTimeoutRef.current) {
            clearTimeout(audioTimeoutRef.current);
            audioTimeoutRef.current = null;
        }

        if (currentlyPlayingRef.current) {
            const audio = currentlyPlayingRef.current;

            // Clear Audio-spezifische Timer
            if (audio.fallbackTimer) {
                clearTimeout(audio.fallbackTimer);
                audio.fallbackTimer = null;
            }

            // Audio stoppen
            audio.pause();
            audio.currentTime = 0;
            audio.onended = null;

            currentlyPlayingRef.current = null;
        }

        // ‚úÖ LOCKS zur√ºcksetzen
        isPlayingAudioRef.current = false;
    }, []);

    // ‚úÖ REF-BASIERT: Auto-Play starten mit Start-Flag
    const startAutoPlay = useCallback(() => {
        if (!scrollToTitleIndex) {
            console.warn('‚ùå scrollToTitleIndex function not available');
            alert('Auto-Play nicht verf√ºgbar - scrollToTitleIndex fehlt');
            return;
        }

        console.log(`‚ñ∂Ô∏è Auto-Play gestartet von Phase ${currentTitleIndex}`);
        isAutoPlayingRef.current = true;
        isAutoPlayStartingRef.current = true;
        setAutoPlayUIState(true); // UI-Update

        // Starte immer mit Phase 1, unabh√§ngig von aktueller Phase
        if (currentTitleIndex !== 1) {
            console.log(`üéØ Gehe zu Phase 1 um Auto-Play zu starten`);
            scrollToTitleIndex(1);
        } else {
            // Schon in Phase 1, starte Audio direkt
            console.log(`üéµ Starte Audio f√ºr Phase 1 direkt`);
            isAutoPlayStartingRef.current = false; // Start-Phase beendet
            setTimeout(() => playAudio(0), 300); // Phase 1 = Index 0
        }
    }, [currentTitleIndex, scrollToTitleIndex, playAudio]);

    // ‚úÖ REF-BASIERT: Auto-Play stoppen/pausieren
    const stopAutoPlay = useCallback(() => {
        console.log(`‚è∏Ô∏è Auto-Play gestoppt`);
        isAutoPlayingRef.current = false;
        isAutoPlayStartingRef.current = false;
        setAutoPlayUIState(false); // UI-Update
        stopAudio();
    }, [stopAudio]);

    // ‚úÖ REF-BASIERT: Detect manueller Scroll - Ignoriert Auto-Play Start
    useEffect(() => {
        if (currentTitleIndex !== lastManualPhaseRef.current) {
            console.log(`üîÑ Phase change: ${lastManualPhaseRef.current} ‚Üí ${currentTitleIndex}, Auto-Play: ${isAutoPlayingRef.current}, Starting: ${isAutoPlayStartingRef.current}`);

            // ‚úÖ WICHTIG: Ignoriere Phase-Wechsel w√§hrend Auto-Play Start
            if (isAutoPlayStartingRef.current) {
                console.log(`üöÄ Auto-Play Start-Phase - ignoriere manueller-Scroll-Check`);
                isAutoPlayStartingRef.current = false; // Start-Phase beendet
                lastManualPhaseRef.current = currentTitleIndex;
                return;
            }

            // Nur stoppen wenn es ein GROSSER Sprung ist oder wenn zu Phase 0 zur√ºckgegangen wird
            if (isAutoPlayingRef.current) {
                const phaseDifference = Math.abs(currentTitleIndex - lastManualPhaseRef.current);

                // Stoppe Auto-Play nur bei:
                // 1. Sprung zu Phase 0 (zur√ºck zum Anfang)
                // 2. Sprung von mehr als 1 Phase (z.B. 2 ‚Üí 5)
                if (currentTitleIndex === 0 || phaseDifference > 1) {
                    console.log(`üëÜ Manueller Scroll erkannt (Sprung: ${phaseDifference}) - Auto-Play gestoppt`);
                    isAutoPlayingRef.current = false;
                    setAutoPlayUIState(false); // UI-Update
                } else {
                    console.log(`‚úÖ Normale Auto-Play Progression (${lastManualPhaseRef.current} ‚Üí ${currentTitleIndex})`);
                }
            }

            lastManualPhaseRef.current = currentTitleIndex;
        }
    }, [currentTitleIndex]); // ‚úÖ KEINE AUTO-PLAY DEPENDENCY!

    // ‚úÖ ANTI-STOTTER: Reagiere auf Phase-Wechsel (mit Verz√∂gerung)
    useEffect(() => {
        console.log(`üìç Phase gewechselt zu: ${currentTitleIndex}, Auto-Play: ${isAutoPlayingRef.current}, Scroll-Lock: ${isScrollLocked}`);

        // ‚úÖ CLEANUP: Clear bestehende Audio-Timeouts bei Phase-Wechsel
        if (audioTimeoutRef.current) {
            clearTimeout(audioTimeoutRef.current);
            audioTimeoutRef.current = null;
        }

        if (currentTitleIndex === 0) {
            // Phase 0: Logo/Newsletter - stoppe alles NUR wenn Auto-Play nicht l√§uft
            if (!isAutoPlayingRef.current) {
                console.log(`üè† Phase 0 erreicht - stoppe Audio`);
                stopAudio();
            } else {
                console.log(`üè† Phase 0 erreicht - aber Auto-Play l√§uft, behalte Einstellungen`);
            }
            return;
        }

        // Phase 1-6: Spiele Audio ab (mit Anti-Stotter-Verz√∂gerung)
        if (currentTitleIndex >= 1 && currentTitleIndex <= 6) {
            const audioIndex = currentTitleIndex - 1; // Phase 1-6 ‚Üí Index 0-5

            // ‚úÖ ANTI-STOTTER: Verz√∂gerung nur bei Auto-Play (f√ºr sanfte √úberg√§nge)
            if (isAutoPlayingRef.current) {
                console.log(`üéµ Auto-Play: Starte Audio f√ºr Phase ${currentTitleIndex} in 1s (Index ${audioIndex})`);
                audioTimeoutRef.current = setTimeout(() => {
                    // Doppelt pr√ºfen ob Auto-Play noch aktiv ist
                    if (isAutoPlayingRef.current) {
                        playAudio(audioIndex);
                    }
                }, 1000); // 1 Sekunde Verz√∂gerung f√ºr sanfte √úberg√§nge
            }
            // Bei manuellem Scroll: Sofort, nur wenn scroll locked
            else if (isScrollLocked) {
                console.log(`üéµ Manuell: Starte Audio f√ºr Phase ${currentTitleIndex} sofort (Index ${audioIndex})`);
                // Kurze Verz√∂gerung auch hier f√ºr bessere UX
                audioTimeoutRef.current = setTimeout(() => {
                    playAudio(audioIndex);
                }, 300);
            }
        }
    }, [currentTitleIndex, isScrollLocked, playAudio, stopAudio]); // ‚úÖ KEINE AUTO-PLAY DEPENDENCY!

    // ‚úÖ REF-BASIERT: Audio-Toggle f√ºr User-Kontrolle
    const toggleAudio = useCallback(() => {
        setIsAudioEnabled(prev => {
            const newState = !prev;
            if (!newState) {
                stopAudio();
                isAutoPlayingRef.current = false;
                isAutoPlayStartingRef.current = false;
                setAutoPlayUIState(false); // UI-Update
            }

            console.log(`üéµ Audio ${newState ? 'aktiviert' : 'deaktiviert'}`);
            return newState;
        });
    }, [stopAudio]);

    // ‚úÖ VOLLST√ÑNDIGES Cleanup bei Unmount
    useEffect(() => {
        return () => {
            console.log(`üßπ TitleAudioLayer Cleanup - stoppe alles`);

            // Clear alle Timer
            if (audioTimeoutRef.current) {
                clearTimeout(audioTimeoutRef.current);
            }

            // Clear alle Audio-Timer
            audioRefs.current.forEach(audio => {
                if (audio && audio.fallbackTimer) {
                    clearTimeout(audio.fallbackTimer);
                }
            });

            stopAudio();
        };
    }, [stopAudio]);

    // ‚úÖ BUTTONS VIA PORTAL - Garantiert au√üerhalb der Layer-Hierarchie
    const buttonsContent = buttonPortal ? createPortal(
        <div style={{ pointerEvents: 'none', width: '100%', height: '100%' }}>
            {/* ‚úÖ AUTO-PLAY BUTTON (nur in Phase 0) */}
            {currentTitleIndex === 0 && (
                <button
                    onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('üéØ Auto-Play Button geklickt!');
                        autoPlayUIState ? stopAutoPlay() : startAutoPlay();
                    }}
                    disabled={!scrollToTitleIndex}
                    style={{
                        position: 'absolute',
                        bottom: '80px',
                        left: '50%',
                        transform: 'translateX(-50%)',
                        width: '80px',
                        height: '80px',
                        borderRadius: '50%',
                        background: autoPlayUIState ?
                            'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)' :
                            'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                        border: 'none',
                        color: 'white',
                        fontSize: '28px',
                        cursor: scrollToTitleIndex ? 'pointer' : 'not-allowed',
                        pointerEvents: 'all',
                        transition: 'all 0.3s ease',
                        boxShadow: '0 8px 25px rgba(0,0,0,0.4)',
                        opacity: scrollToTitleIndex ? 1 : 0.5,
                        zIndex: 1,
                        // Anti-Selection
                        userSelect: 'none',
                        WebkitUserSelect: 'none',
                        MozUserSelect: 'none',
                        msUserSelect: 'none'
                    }}
                    title={
                        !scrollToTitleIndex
                            ? 'Auto-Play nicht verf√ºgbar'
                            : autoPlayUIState
                                ? 'Auto-Play pausieren'
                                : 'Auto-Play starten (komplette Sequenz)'
                    }
                >
                    {autoPlayUIState ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                </button>
            )}

            {/* ‚úÖ AUDIO CONTROL (immer sichtbar) */}
            <button
                onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üîä Audio Toggle geklickt!');
                    toggleAudio();
                }}
                style={{
                    position: 'absolute',
                    bottom: '20px',
                    right: '20px',
                    width: '60px',
                    height: '60px',
                    borderRadius: '50%',
                    background: isAudioEnabled ?
                        'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' :
                        'rgba(100, 100, 100, 0.8)',
                    border: 'none',
                    color: 'white',
                    fontSize: '24px',
                    cursor: 'pointer',
                    pointerEvents: 'all',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 4px 15px rgba(0,0,0,0.3)',
                    zIndex: 1,
                    userSelect: 'none',
                    WebkitUserSelect: 'none',
                    MozUserSelect: 'none',
                    msUserSelect: 'none'
                }}
                title={isAudioEnabled ? 'Audio stumm schalten' : 'Audio aktivieren'}
            >
                {isAudioEnabled ? 'üîä' : 'üîá'}
            </button>

            {/* ‚úÖ ERWEITERTES DEBUG PANEL */}
            {process.env.NODE_ENV === 'development' && (
                <div
                    style={{
                        position: 'absolute',
                        top: '120px',
                        right: '10px',
                        background: 'rgba(0,0,0,0.9)',
                        color: 'white',
                        padding: '12px',
                        fontSize: '11px',
                        borderRadius: '6px',
                        pointerEvents: 'all',
                        fontFamily: 'monospace',
                        lineHeight: '1.4',
                        border: '1px solid #333',
                        backdropFilter: 'blur(10px)',
                        zIndex: 1,
                        minWidth: '200px'
                    }}
                >
                    <div style={{ fontWeight: 'bold', marginBottom: '8px', color: '#4CAF50' }}>
                        üéµ Audio-Debug (Portal)
                    </div>
                    <div>üìç Phase: {currentTitleIndex}/6</div>
                    <div>üîä Audio: {isAudioEnabled ? 'An' : 'Aus'}</div>
                    <div style={{ color: autoPlayUIState ? '#4CAF50' : '#ff9800' }}>
                        ‚ñ∂Ô∏è Auto-Play: {autoPlayUIState ? '‚úÖ L√ÑUFT' : '‚ùå GESTOPPT'}
                        {isAutoPlayStartingRef.current && ' üöÄ'}
                    </div>
                    <div style={{ fontSize: '9px', color: '#888' }}>
                        ‚îî Starting: {isAutoPlayStartingRef.current ? 'JA' : 'NEIN'} | Letzte Phase: {lastManualPhaseRef.current}
                    </div>
                    <div style={{ fontSize: '9px', color: '#4CAF50' }}>
                        üîß Ref-Status: {isAutoPlayingRef.current ? 'TRUE' : 'FALSE'}
                    </div>
                    <div style={{ fontSize: '9px', color: '#888' }}>
                        üîí Audio-Lock: {isPlayingAudioRef.current ? 'LOCKED' : 'FREE'}
                    </div>
                    <div style={{ fontSize: '9px', color: '#888' }}>
                        ‚è±Ô∏è Timer: {audioTimeoutRef.current ? 'AKTIV' : 'IDLE'}
                    </div>
                    <div style={{ fontSize: '9px', color: '#888' }}>
                        üéØ scrollToTitleIndex: {scrollToTitleIndex ? '‚úÖ' : '‚ùå'}
                    </div>
                    <div style={{ fontSize: '9px', color: '#888' }}>
                        üåê Portal: {buttonPortal ? '‚úÖ' : '‚ùå'}
                    </div>
                    <div style={{ marginTop: '4px', fontSize: '10px', color: '#888' }}>
                        üé∂ Playing: {currentlyPlayingRef.current ?
                            titleAudios[currentTitleIndex - 1]?.title || 'Unknown' :
                            'None'
                        }
                    </div>

                    <div style={{ marginTop: '8px', borderTop: '1px solid #333', paddingTop: '8px' }}>
                        <button
                            onClick={toggleAudio}
                            style={{
                                padding: '4px 8px',
                                fontSize: '10px',
                                background: isAudioEnabled ? '#ff4444' : '#44ff44',
                                color: 'white',
                                border: 'none',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                pointerEvents: 'all',
                                marginRight: '4px'
                            }}
                        >
                            {isAudioEnabled ? 'üîá' : 'üîä'}
                        </button>

                        <button
                            onClick={() => {
                                console.log('üêõ Manual Debug Info:');
                                console.log('currentTitleIndex:', currentTitleIndex);
                                console.log('autoPlayUIState:', autoPlayUIState);
                                console.log('isAutoPlayingRef.current:', isAutoPlayingRef.current);
                                console.log('isAutoPlayStartingRef.current:', isAutoPlayStartingRef.current);
                                console.log('isPlayingAudioRef.current:', isPlayingAudioRef.current);
                                console.log('audioTimeoutRef.current:', audioTimeoutRef.current);
                                console.log('isScrollLocked:', isScrollLocked);
                                console.log('currentlyPlaying:', currentlyPlayingRef.current);
                                console.log('scrollToTitleIndex available:', !!scrollToTitleIndex);

                                // Audio-Status f√ºr alle Elemente
                                audioRefs.current.forEach((audio, index) => {
                                    if (audio) {
                                        console.log(`Audio ${index + 1} - readyState: ${audio.readyState}, duration: ${audio.duration}, currentTime: ${audio.currentTime}`);
                                    }
                                });
                            }}
                            style={{
                                padding: '4px 8px',
                                fontSize: '10px',
                                background: '#2196F3',
                                color: 'white',
                                border: 'none',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                pointerEvents: 'all'
                            }}
                        >
                            üìä Log
                        </button>
                    </div>

                    <div style={{ marginTop: '6px', fontSize: '9px', opacity: 0.7 }}>
                        ‚ùå Errors: {Object.values(errorStates).filter(Boolean).length}/6
                    </div>

                    {autoPlayUIState && (
                        <div style={{
                            marginTop: '4px',
                            fontSize: '9px',
                            color: '#4CAF50',
                            animation: 'pulse 2s infinite'
                        }}>
                            üé¨ Auto-Play l√§uft...
                        </div>
                    )}
                </div>
            )}
        </div>,
        buttonPortal
    ) : null;

    return (
        <ErrorBoundary>
            {/* Audio-Elemente (versteckt) */}
            <div style={{ display: 'none' }}>
                {titleAudios.map((audioConfig, index) => (
                    <audio
                        key={audioConfig.id}
                        ref={el => audioRefs.current[index] = el}
                        preload="auto"
                        onLoadedData={() => handleAudioLoad(index)}
                        onError={(e) => handleAudioError(index, e)}
                        onLoadStart={() => setLoadingStates(prev => ({ ...prev, [index]: true }))}
                    >
                        <source
                            src={`${audioConfig.basePath}.mp3`}
                            type="audio/mpeg"
                        />
                    </audio>
                ))}
            </div>

            {/* ‚úÖ BUTTONS VIA PORTAL - Garantiert klickbar */}
            {buttonsContent}
        </ErrorBoundary>
    );
};

export default TitleAudioLayer;